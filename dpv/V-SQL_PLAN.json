[ [ "ADDRESS", "RAW(4 | 8)", "<p>Address of the handle to the parent for this cursor</p>" ], [ "HASH_VALUE", "NUMBER", "<p>Hash value of the parent statement in the library cache. The two columns <code>ADDRESS</code> and <code>HASH_VALUE</code> can be used to join with <code>V$SQLAREA</code> to add the cursor-specific information.</p>" ], [ "SQL_ID", "VARCHAR2(13)", "<p>SQL identifier of the parent cursor in the library cache</p>" ], [ "PLAN_HASH_VALUE", "NUMBER", "<p>Numerical representation of the current SQL plan for this cursor. Comparing one <code>PLAN_HASH_VALUE</code> to another easily identifies whether or not two plans are the same (rather than comparing the two plans line by line).</p>" ], [ "FULL_PLAN_HASH_VALUE", "NUMBER", "<p>Numeric representation of the complete SQL plan for this cursor. Comparing one <code>FULL_PLAN_HASH_VALUE</code> to another easily identifies whether or not two plans are the same (rather than comparing the two plans line by line). Note that the <code>FULL_PLAN_HASH_VALUE</code> cannot be compared across databases releases. It is not backward compatible.</p>" ], [ "CHILD_ADDRESS", "RAW(4 | 8)", "<p>Address of the child cursor</p>" ], [ "CHILD_NUMBER", "NUMBER", "<p>Number of the child cursor that uses this execution plan. The columns <code>ADDRESS</code>, <code>HASH_VALUE</code>, and <code>CHILD_NUMBER</code> can be used to join with <code>V$SQL</code> to add the child cursor-specific information.</p>" ], [ "TIMESTAMP", "DATE", "<p>Date and time when the execution plan was generated</p>" ], [ "OPERATION", "VARCHAR2(30)", "<p>Name of the internal operation performed in this step (for example, <code>TABLE ACCESS</code>)</p>" ], [ "OPTIONS", "VARCHAR2(30)", "<p>A variation on the operation described in the <code>OPERATION</code> column (for example, <code>FULL</code>)</p>" ], [ "OBJECT_NODE", "VARCHAR2(40)", "<p>Name of the database link used to reference the object (a table name or view name). For local queries that use parallel execution, this column describes the order in which output from operations is consumed.</p>" ], [ "OBJECT#", "NUMBER", "<p>Object number of the table or the index</p>" ], [ "OBJECT_OWNER", "VARCHAR2(30)", "<p>Name of the user who owns the schema containing the table or index</p>" ], [ "OBJECT_NAME", "VARCHAR2(30)", "<p>Name of the table or index</p>" ], [ "OBJECT_ALIAS", "VARCHAR2(65)", "<p>Alias for the object</p>" ], [ "OBJECT_TYPE", "VARCHAR2(20)", "<p>Type of the object</p>" ], [ "OPTIMIZER", "VARCHAR2(20)", "<p>Current mode of the optimizer for the first row in the plan (statement line), for example, <code>CHOOSE</code>. When the operation is a database access (for example, <code>TABLE ACCESS</code>), this column indicates whether or not the object is analyzed.</p>" ], [ "ID", "NUMBER", "<p>A number assigned to each step in the execution plan</p>" ], [ "PARENT_ID", "NUMBER", "<p>ID of the next execution step that operates on the output of the current step</p>" ], [ "DEPTH", "NUMBER", "<p>Depth (or level) of the operation in the tree. It is not necessary to issue a <code>CONNECT BY</code> statement to get the level information, which is generally used to indent the rows from the <code>PLAN_TABLE</code> table. The root operation (statement) is level 0.</p>" ], [ "POSITION", "NUMBER", "<p>Order of processing for all operations that have the same <code>PARENT_ID</code></p>" ], [ "SEARCH_COLUMNS", "NUMBER", "<p>Number of index columns with start and stop keys (that is, the number of columns with matching predicates)</p>" ], [ "COST", "NUMBER", "<p>Cost of the operation as estimated by the optimizer's cost-based approach. For statements that use the rule-based approach, this column is null.</p>" ], [ "CARDINALITY", "NUMBER", "<p>Estimate, by the cost-based optimizer, of the number of rows produced by the operation</p>" ], [ "BYTES", "NUMBER", "<p>Estimate, by the cost-based optimizer, of the number of bytes produced by the operation</p>" ], [ "OTHER_TAG", "VARCHAR2(35)", "<p>Describes the contents of the <code>OTHER</code> column. See <code>EXPLAIN PLAN</code> for values.</p>" ], [ "PARTITION_START", "VARCHAR2(64)", "<p>Start partition of a range of accessed partitions</p>" ], [ "PARTITION_STOP", "VARCHAR2(64)", "<p>Stop partition of a range of accessed partitions</p>" ], [ "PARTITION_ID", "NUMBER", "<p>Step that computes the pair of values of the <code>PARTITION_START</code> and <code>PARTITION_STOP</code> columns</p>" ], [ "OTHER", "VARCHAR2(4000)", "<p>Other information specific to the execution step that users may find useful. See <code>EXPLAIN PLAN</code> for values.</p>" ], [ "DISTRIBUTION", "VARCHAR2(20)", "<p>Stores the method used to distribute rows from producer query servers to consumer query servers</p>" ], [ "CPU_COST", "NUMBER", "<p>CPU cost of the operation as estimated by the optimizer's cost-based approach. For statements that use the rule-based approach, this column is null.</p>" ], [ "IO_COST", "NUMBER", "<p>I/O cost of the operation as estimated by the optimizer's cost-based approach. For statements that use the rule-based approach, this column is null.</p>" ], [ "TEMP_SPACE", "NUMBER", "<p>Temporary space usage of the operation (sort or hash-join) as estimated by the optimizer's cost-based approach. For statements that use the rule-based approach, this column is null.</p>" ], [ "ACCESS_PREDICATES", "VARCHAR2(4000)", "<p>Predicates used to locate rows in an access structure. For example, start or stop predicates for an index range scan.</p>" ], [ "FILTER_PREDICATES", "VARCHAR2(4000)", "<p>Predicates used to filter rows before producing them</p>" ], [ "PROJECTION", "VARCHAR2(4000)", "<p>Expressions produced by the operation</p>" ], [ "TIME", "NUMBER", "<p>Elapsed time (in seconds) of the operation as estimated by the optimizer's cost-based approach. For statements that use the rule-based approach, this column is null.</p>" ], [ "QBLOCK_NAME", "VARCHAR2(30)", "<p>Name of the query block</p>" ], [ "REMARKS", "VARCHAR2(4000)", "<p>Remarks</p>" ], [ "OTHER_XML", "CLOB", "<p>Provides extra information specific to an execution step of the execution plan. The content of this column is structured using XML since multiple pieces of information can be stored there. This includes:</p>\n<ul style=\"list-style-type: disc;\">\n<li>\n<p>Name of the schema against which the query was parsed</p>\n</li>\n<li>\n<p>Release number of the Oracle Database that produced the explain plan</p>\n</li>\n<li>\n<p>Hash value associated with the execution plan</p>\n</li>\n<li>\n<p>Name (if any) of the outline or the SQL profile used to build the execution plan</p>\n</li>\n<li>\n<p>Indication of whether or not dynamic statistics were used to produce the plan</p>\n</li>\n<li>\n<p>The outline data, a set of optimizer hints that can be used to regenerate the same plan</p>\n</li>\n<li>\n<p>Additional data that describes the relationship between rows in the plan table and subplans of adaptive plans. Note that in Oracle Database 12<span class=\"italic\">c</span>, there will be extra rows in the plan table and <code>V$SQL_PLAN</code>.</p>\n</li>\n</ul>" ], [ "CON_ID", "NUMBER", "<p>The ID of the container to which the data pertains. Possible values include:</p>\n<ul style=\"list-style-type: disc;\">\n<li>\n<p><code>0</code>: This value is used for rows containing data that pertain to the entire CDB. This value is also used for rows in non-CDBs.</p>\n</li>\n<li>\n<p><code>1</code>: This value is used for rows containing data that pertain to only the root</p>\n</li>\n<li>\n<p><span class=\"italic\">n</span>: Where <span class=\"italic\">n</span> is the applicable container ID for the rows containing data</p>\n</li>\n</ul>" ] ]